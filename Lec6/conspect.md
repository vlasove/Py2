## Лекция 6. (Продолжение Лекции 5)

Не смотря на проблемы, у процедурного подхода были и свои плюсы:
* 100%-ая ***однозначность*** и ***строгость*** типов

### Про классы
***Класс*** - это инструкция порождения сущностей, содержащая в себе информацию как про ***состояние***(атрибуты) так и про ***поведение*** (методы). В отличие от структур, класс - это не только набор полей, но и еще "встроенных" функций (методов) , которые отвечают на вопрос : **А что оно умеет делать?**

## Важные определения
* ***Класс*** - инструкция порождения сущностей , с заранее определенным поведением (поведенческий паттерн)
* ***Атрибут (класса)*** - переменная, определенная внутри класса
* ***Метод (класса)*** - функция, определенная внутри класса
* ***Объект (класса)*** - что-то (материальное), что было создано по инструкции (порождение класса).

***Важно помнить***, что все методы в качестве первого аргумента принимают объект класса, с которым метод работает.
Данный аргумент принято обозначать ***self***.

### Определение от Святослава
***self*** указывает на то, что методы объектозависимые

## Несколько примеров
* Пример с книгой
```
class Book:
    title = ""
    author = ""

    def read(self):
        """
        Метод выводит на консоль факт того, что эту книгу читают
        """
        print("Now I'm reading book with title:", self.title, "and author:", self.author)

    def get_title(self):
        """
        Метод возвращает название книги
        """
        return self.title 

    def get_author(self):
        """
        Метод возвращает автора книги
        """
        return self.author

b = Book()
b.title = "HP:1"
b.author = "J. Rawling"

b.read()
print("Title:", b.get_title())
print("Author:", b.get_author())
```

* Пример с машиной:
```
class Car:
    price = 0
    rating = 0.0 
    mark = ""
    hp = 0

    def ride(self):
        print("Now I'm riding on my super :", self.mark)
        print("My HP:", self.hp)

    def tuning(self, hp_dop):
        """
        Добавляем лошадиных сил
        """
        self.hp = self.hp + hp_dop

def create_car(price_arg, rating_arg, mark_arg, hp_arg) -> Car:
    """
    Создаем машину и возвращаем
    """
    c = Car()
    c.price = price_arg
    c.rating = rating_arg
    c.mark = mark_arg
    c.hp = hp_arg
    return c 

c1 = create_car(100, 0.00009, "Lada", -2)
c2 = create_car(200000000, 2.0, "Bugatti", -1)
c3 = create_car(30000, 5.0, "BMW", 0)
cars = [c1, c2, c3]
for car in cars:
    car.ride()
    car.tuning(15)
    car.ride()
```

## Теперь у нас есть проблема
***Проблема*** - функция для создания новых объектов классов , находится за пределами класса. Но эта функция имеет непосредственное отношение к классу. По законам здравой логики, мы понимаем, что данная функция описывает поведение, а значит, ***должна быть определена*** внутри класса.

### Исходный вид
```
class Point:
    x = 0
    y = 0 


def create_point(x_coord, y_coord):
    p = Point()
    p.x, p.y = x_coord, y_coord
    return p 
```

### Вариант 1. 
Запихаем в класс эту функцию с минимум изменений:
```
class Point:
    x = 0
    y = 0 


    def create_point(self, x_coord, y_coord):
        p = Point()
        p.x, p.y = x_coord, y_coord
        return p 


p = Point()
new_p = p.create_point(10, 20) #new_p - это созданная точка
```
***Беда*** в том - чтобы создать объект с каким-то значениями атрибутов, необходимо создать промежуточный объект.

### Вариант 2.
Запихаем в класс и немного поменяем, чтобы изменялись поля объекта
```
class Point:
    x = 0
    y = 0 


    def create_point(self, x_coord, y_coord):
        self.x, self.y = x_coord, y_coord
        


p = Point()
p.create_point(10, 20) #теперь в p (x=10, y=20)
```
***Беда*** в том - что вроде эта операция стандартная (АБСОЛЮТНО КАЖДЫЙ объект должен уметь создаваться) , а название данного метода я могу выбрать абсолютно любым

### Вариант 3.
Использовать специальный метод, который вводится в класс для конфигурирования ***состояния*** объектов - и называется этот метод ***конструктор*** ```__init__(self, ....)```:
```
class Point:
    x = 0
    y = 0 

    def __init__(self, x_coord, y_coord):
        self.x, self.y = x_coord, y_coord
```

В более удобной форме:
```
class Point:
    x = 0
    y = 0 

    def __init__(self, X_FROM_INIT, Y_FROM_INIT):
        self.x, self.y = X_FROM_INIT, Y_FROM_INIT
        
    def print_point(self):
        print("X:", self.x, "Y:", self.y)

p = Point(10, 20)
p.print_point()
```

***Что нужно помнить?*** Нужно помнить, что метод ```__init__``` является ***специальным*** и вызывается ***ПРИ СОЗДАНИИ ОБЪЕКТА***.

Супер итоговая версия:
```
class Point:
    def __init__(self, X_FROM_INIT, Y_FROM_INIT):
        self.x, self.y = X_FROM_INIT, Y_FROM_INIT
        
    def print_point(self):
        print("X:", self.x, "Y:", self.y)
```
Убрали ```x = 0 y = 0``` потому что при обращении ***ВНУТРИ КЛАССА*** вида:
```
.....
    self.x = 2000
....
```
создается атрибут ```x``` со значением ```200```.

## Умная мысль
***Всегда определяйте*** все атрибуты внутри конструктора. ***Не делайте вот так!!!!!***:
```
class Point:
    def __init__(self, X_FROM_INIT, Y_FROM_INIT):
        self.x = X_FROM_INIT
        self.y = Y_FROM_INIT
        
    def print_point(self):
        print("X:", self.x, "Y:", self.y)
        self.z = 200

    def print_point_Z(self):
        print("X:", self.x, "Y:", self.y, "Z:", self.z)
```
***Почему?*** Да потому, что в этой ситуации ***СОСТОЯНИЕ*** объекта ***БУДЕТ МЕНЯТЬСЯ*** в ходе его функционирования.