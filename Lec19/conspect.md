## Лекция 19. Модуль collections

***Проблема:*** при работе с примитивными коллекциями очень часто возникают похожие задачи.

### Шаг 1. Counter
```collections.Counter``` - это класс, который очень сильно похож на классический словарь, за тем исключением, что он в автоматическом порядке решает задачу ***частотного анализа*** (может ответить на вопрос, сколько раз тот или иной элемент встречался).

Если у двух элементов одинаковые частоты, то:
* Если версия интерпретатор меньше ```3.7``` - выбирается лексикографически меньший
* Если версия больше ```>=3.7``` - выбирается тот, кто встречался первее

```
import collections
word = ["bob", "alice", "fedya", "cat", "dog", "bob", "alice", "fedya", "bob"]
counter = collections.Counter(word) # На вход Counter() можно скормить ЛЮБОЙ ИТРЕИРУЕМЫЙ ОБЪЕКТ
print(counter)
print("bob:", counter["bob"])

print("Elements:", list(counter.elements()))

print("Top 2 words:", counter.most_common(3))

# Сходство с нижележащим словарем
for key, val in counter.items():
    print(key, val)
```

### Шаг 2. Словарь со значением по умолчанию
Зачастую мы сталкивались с проблемой, которая заключается в следующем:
* у нас есть словарь и мы пытаемся обратиться к ключу , которого не существует
```
d = {"one":1, "two":2, "three": 3}
d["four"]
```
* хотелось бы, чтобы если ключа не было - пара инициализировалась бы со значением по умолчанию (так работает по умолчанию ```map``` в ```C++``` или ```Java```)
```
import collections
d = collections.defaultdict(int)
d["one"] = 1
d["two"] = 2
d["three"]
print(d)
d["three"] = 3
print(d)

for key, val in d.items():
    print(key, val)
```

В качестве значения по умолчанию можем использовать любой ```Python``` примитив (базовые типы, коллекции, встроенные классы). Если хочется использовать в качестве значения по умолчанию пользовательский класс - необходимо реализовать метод ```__hash``` (подробнее, см. ```Fluent Python```)

### Шаг 3. Слияение словарей
Представим что у нас есть компутер, с размером оперативной памяти ```X```. В ходе работы ```Python``` приложения мы создаем 2 словаря ```a``` и ```b```. Размер словаря ```a``` = ```X/2```, размер словаря ```b``` = ```X/2 - 100```, ```100 << X```. У нас задача - соединить 2 словаря в один.

```
a = {"one" : 1, "two" : 2}
b = {"three" : 3, "four" : 4}
c = {"five" : 5, "one" : 3}
import collections

totaldict = collections.ChainMap(a, b)
a.pop("one")
totaldict["vova"] = 10
totaldict = totaldict.new_child(c)
for key, val in totaldict.items():
    print(key, val)

print(totaldict["one"])

```

### Шаг 4. Структуры? Они существуют?
Бывают такие моменты, когда нам нужны отображения классических структур (структура - это заименованный набор полей, описывающих состояние представителя).

Раньше делали так, но как-то сложно для простейшей структуры.
```
class Point:
    def __init__(self, x, y):
        self.x = x 
        self.y = y 

    def __str__(self):
        return f'Point(x = {self.x}, y = {self.y})'
```

Решение:
```
NewPoint = collections.namedtuple('NewPoint', ['x', 'y'])
```

Полученный ```NewPoint``` это обычный класс с реализованынми методами ```__init__``` и ```__str__```. Что очень экономит нам время, на описание данной конструкции в ручном формате.

### Шаг 5. deque - способ реализации очереди или стека.
```colelctions.deque``` - это функция, возвращающая класс ```Deque```, который имеет весь необходимый функционал для реализации очереди или стека, или гибридной очереди и т.д. То есть служит для реализации структур данных с последовательным доступом.