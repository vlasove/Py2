## Лекция 14. Множественное наследование

***Задача***: как реализован механизм множественного наследования в Python?

### Шаг 1. Простейшая реализация множественного наследования
```
class B:
    b = 10

class C:
    c = 20

class A(B,C):
    a = 30

obj_a = A()
print("obj_a.a:", obj_a.a)
print("obj_a.b:", obj_a.b)
print("obj_a.c:", obj_a.c)
```

### Шаг 2. Проблема переопределений (или Ромбическая проблема)
```
class B:
    b = 10

    def print_me(self):
        print("b from B:", self.b)

class C:
    c = 20

    def print_me(self):
        print("c from C:", self.c)

class A(C, B):
    a = 30
    
    def print_me(self):
        super().print_me() # Обращение к первому родителю
        B.print_me(self) # Явное обращение к другому классу
        print("a from A:", self.a)

```
В языке ***Python*** проблема переопределений родительских методов/атрибутов решается по следующему правилу:
* Говорят, что самым больишм приоритетом обладает тот класс, который стоит левее в цепочке наследования ``` A(C, B)```. В данном случае, это класс ```C```
* Перепопределяющий метод/атрибут выбирает у класса с самым высоким приоритетом. 