## Лекция 8. Стандартные методы

### Шаг 1. Переопределение функций
Поскольку интерпретатор читает модуль сверху-вниз, то в ситуации, если встречаются функции с одинаковыми ***именами***, то в итоге, валидной функцией с именем ```name``` будет та, которая встречалась ближе всего к моменту вызова этой функции:
```
def add(a:int, b:int):
    """
    a + b 
    """
    return a + b 



def add(a:int, b:int, c:int):
    """
    a**2 + b**2
    """
    return a**2 + b**2  + c**2



print(add(2,3,4))
```
Будет вызвана функция с сигнатурой ``` def add(a:int, b:int, c:int)```

### Шаг 2. Переопределение методов
Аналогичная история сопровождает и методы (поскольку метод является так же ***САМОЙ ОБЫЧНОЙ ФУНКЦИЕЙ***) то зависимость переопределения от имени метода - точно такая же как и у обычных функций:
```
class Calculator:
    def __init__(self, x:int, y:int):
        self.x_value = x 
        self.y_value = y 


    def calc(self):
        return self.x_value + self.y_value

    def calc(self):
        return self.x_value ** 2 + self.y_value ** 2


c = Calculator(2,10)
print(c.calc())
```