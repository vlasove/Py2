## Секретная лекция. Лекция 16.

***Проблема:*** а всегда ли методы классов используют ```self```? То есть всегда ли методы классов завязаны на объектах? Не может ли быть такого, что метод будет привязан скорее к классу, а не к конкретному объекту?

### Шаг 1. ```@classmethod``` 
```
class Book:
    path_to_db = "database.db" # Классовые атрибуты

    def __init__(self, title, pages, author, price):
        self.title = title 
        self.pages = pages 
        self.author = author
        self.price = price 

    @classmethod 
    def born_book(cls, new_title):
        return cls(new_title, 0, None, 0)

```
При помощи декоратора ```@classmethod``` можно обозначить метод внутри класса, который работает не с каким-то конкретными объектом (в отличии от ```self```), а завязан целиком на самом классе.


### Шаг 2. ```@staticmethod```
```
@staticmethod
def create_databse(path_to_file):
    with open(path_to_file, "w") as fhand:
        fhand.write("created")
```

Декоратор ```@staticmethod``` позволяет определять внутри класса методы, которые ***НЕ ПРИВЯЗАНЫ НИ К КЛАССУ, НИ К ОБЪЕКТАМ**** , но тем не менее выполняют работу, которая необходима для нормального функционирования класса или новых объектов. В нашем примере мы создали файл-базу данных - это хранилище всех наших последующих книг класса ```Book```


