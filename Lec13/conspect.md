## Лекция 13. Наследование.

***Наследование*** - способность объектов внимать в себя состояния и поведения уже существующих объектов (родительские объекты) , а также внесения корректировок с целью оптимизации и получения нового функционала (дочерние объекты).

### Шаг 1. Простейшее наследование
Реализуем наследование простейших атрибутов с и спользованием механизма ```CTRL+C CTRL+V```.
```
class Horse:
    """
    Лошадь(конь) - класс родитель
    """
    hooves = 3 # копыта
    tail =  True 
    weight = -50
    body = True 
    love_grass = True 


class Unicorn:
    """
    Наш шедевр. Мы хотим его создать по образу и подобию Horse
    """
    hooves = 3 # копыта
    tail =  True 
    weight = -50
    body = True 
    love_grass = True 
    has_horn = True 


class PegasusWithHorn:
    """
    """
    hooves = 3 # копыта
    tail =  True 
    weight = -50
    body = True 
    love_grass = True 
    has_horn = True 
    can_fly = True 

```
***Что получилось?*** Да, мы действительно создали дочерний класс (```Unicorn```) по отношению к родительскому (```Horse```): класс ```Unicorn``` знает все, что знает ```Horse```, но еще в ```Unicorn``` есть новое поле - ```has_horn```.

***Какая проблема?*** Если ошибиться / захотеть улучшить родительский класс - то все куски кода в дочерних классах придется править руками. Это плохо.

### Шаг 2. Использование механизмов наследования в Python
Использование механзимов наследвоания в языках позволяет решить проблему явного дублирования кода.
```
class Horse:
    """
    Лошадь(конь) - класс родитель
    """
    hooves = 4 # копыта
    tail =  True 
    weight = 250
    body = True 
    love_grass = True 


class Unicorn(Horse):
    """
    Наш шедевр. Мы хотим его создать по образу и подобию Horse
    """
    has_horn = True 
```

Теперь все изменения в родительском классе будут сразу видны в дочернем.

### Шаг 3. Переопределение в наследовании
Что если у дочернего класса хочется переопределить одно из полей/свойств?
```
class A:
    shape = 20
    a = -30


class B(A):
    b = 40
    shape = 100 # Происходит переопределение родительского поля

obj_a = A()
obj_b = B()

print("Info about obj_a", obj_a.a, obj_a.shape)
print("Info about obj_b:", obj_b.a, obj_b.shape, obj_b.b)
```
В данном примере происходит переопределение поля ```shape``` дочерним классом ```B```.

### Шаг 4. Реализация наследования полноценных классов.
```
class Figure:
    """
    Родительский класс - фигура.
    Знает про цвет и красивый ли он?
    """
    def __init__(self, color:str, nice:bool):
        self.color = color
        self.nice = nice 

    def get_color(self):
        return self.color 

    def __str__(self):
        return f'Figure(color={self.color}, nice={self.nice})'

class Circle(Figure):
    """
    Дочерний класс - кружок.
    У него есть цвет, он знает про то, красивый ли он, а еще умеет
    считать периметр и площадь
    """
    
    def __init__(self, color:str, nice:bool, R:float):
        """
        Хотим передать работу родительскому классу по определению
        атрибутов color и nice
        """
        super().__init__(color, nice)
        self.R = R 

    def perimeter(self):
        print(super().get_color())
        return self.R * 3.14 * 2 

    def area(self):
        print(super().get_color())
        return 3.14 * self.R ** 2

    

    def __str__(self):
        return f'Circle(color={self.color}, nice={self.nice}, R={self.R})'
```

Если внутри дочернего класса переопределяется метод/атрибут родительского класса, то есть 2 выхода:
* Переопределение для нас важно и мы можем пользоваться новым методом внутри дочернего класса
* Переопределение для некоторых частей дочернего класса - плохая идея, и придется обращаться к переопределяемому методу родительского класса . Это реализауется через функцию ```super()```. Она позволяет выполнить обращение к ***первому родителю***.