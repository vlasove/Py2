## Лекция 10. Продолжение про инкапсуляцию

### Шаг 1. Предоставление доступа к инкапсулированным состояниям через get/set.
***Проблема*** если инакпсулировать абсолютно все свойства, то пользователю не достанется никаких интерфейсов , позволяющих эффективно использовать объекты класса. Для решения этой задачи используют следующий подход:
* Все поля конструктора делаем ***условно-приватными*** (то есть их названия начинаются с `__`)
* Для того, чтобы пользователь класса мог ***ЧИТАТЬ*** значения приватизированных атрибутов - вводится метод ```get()``` (***гетэр*** - ***get attribute```) ```P.S``` По-хорошему ***на каждый приватный атрибут должен существовать свой гетэр***:
```
    ....
    def get_RAM(self):
        return self.__RAM
    
    def get_freq(self):
        return self.__freq 

    def get_mark(self):
        return self.__mark 
    .....
```
* Для безболезненного (контролируемого) изменения значений приватных атрибутов используют ```сэт-эры```. ***Сэтэр*** - это такой метод, который может изменить значение приватизиованного (инкапсулированного поля) с предварительными проверками. Добавим в наш объект возможность безопасно изменять значения атрибутов ```RAM``` и ```resolution``` :
```
    def set_resolution(self, new_resolution:int):
        if new_resolution <= 0:
            raise ValueError("Разрешение не может быть отрицательным числом!")
        self.__resolution = new_resolution

    
    
    def set_RAM(self, new_RAM:int):
        if new_RAM <= 0:
            raise ValueError("Величина оперативной памяти не может быть отрицательной!")
        self.__RAM = new_RAM
```

После данных операций наш объект представляется в следующем виде:
* У объекта ```SmartPhone``` имеется в наличии 5 приватизированных атрибутов
* У двух атрибутов есть возможность безопасного изменения значений (```set_resolution```, ```set_RAM```)
* У всех атрибутов есть возможность безопасного чтения при помощи методов (```get_RAM```, ```get_freq``` ....)

***После всех этих процедур*** , говорят, что данный класс поддерживает ```инкапсуляцию```.

### Шаг 2. Что такое инкапсуляция?
***Инкапсуляция*** - это возможность разделения структуры класса на ***публичный(пользовательский) интерфейс*** и ***приватный(сокрытый) интерфейс***. На примере ```SmartPhone``` мы создали следующий публичный интерфейс:
* Имеются 5 ***гетэров*** ```get_RAM, get_freq, get_mark``` ....
* Имеется 2 ***сетэра*** ```set_RAM, set_resolution```
* ***Иногда*** к публичному интерфейсу относят ```__init___, __str___``` (все специальные методы, которые мы рассмотрели ранее.)

Все остальное - является приватным интерфейсом.

### Шаг 3. Инкапсулирвоание свойств
Мы рассмотрели инкапсулирование состояний (атрибутов). Но что если нужно сокрыть какой-то функционал?
Представим себе радиоприемник ```Radio```.
```
"""
Модуль содержащий реализацию класса Radio
"""

class Radio:
    """
    Класс Radio = радиоприемник
    Состояние описывается как:
    * model - модель радиоприемника
    * capacity - величина емкости (элемент колебательного контура)
    * volume - громкость (мощность колебаний диафрагмы)

    Публичный интерфейс:
    * get_model()
    * get_capacity()
    * get_volume()
    * set_model()
    * set_capacity()
    * set_volume()
    * change_radiostation() - метод, изменяющий текущую радиоволну
    * change_sound_volume() - метод, который делает тише/громче

    Приватный интерфейс:
    * capacity_up() - увеличивает емкость конденсатора
    * capacity_down() - уменьшает емкость конденсатора
    * volume_up() - увеличивает мощность колебаний диафрагмы
    * volume_down() - уменьшает мощность колебаний диафрагмы
    """
    def __init__(self, model:str, capacity:int, volume:int):
        self.__model = model  
        self.__capacity = capacity 
        self.__volume = volume 

    ### Здесь блок с гетэрами и сетэрами
    def change_radiostation(self, change_to:int):
        if change_to > 0:
            self.__capacity_up(change_to)
        else:
            self.__capacity_down(change_to)

    def change_sound_volume(self, change_to:int):
        if change_to > 0:
            self.__volume_up(change_to)
        else:
            self.__volume_down(change_to)

    def __capacity_up(self, change_to:int):
        print("ПРОИСХОДЯТ СЛОЖНЕЙШИЕ ЭЛЕКТРОТЕХНИЧЕСКИЕ ПРЕОБРАЗОВАНИЯ КОТОРЫЕ МОГУТ ПРИВЕСТИ К СМЕРТИ РАДИОПРИЕМНИКА")
        print("В ИТОГЕ ВСЕ ОК! Частота увелична")
        self.__capacity += change_to

    def __capacity_down(self, change_to:int):
        print("ПРОИСХОДЯТ СЛОЖНЕЙШИЕ ЭЛЕКТРОТЕХНИЧЕСКИЕ ПРЕОБРАЗОВАНИЯ КОТОРЫЕ МОГУТ ПРИВЕСТИ К СМЕРТИ РАДИОПРИЕМНИКА")
        print("В ИТОГЕ ВСЕ ОК! Частота уменьшена")
        self.__capacity -= change_to

    def __volume_up(self, change_to:int):
        pass 

    def __volume_down(self, change_to:int):
        pass 


```

Теперь мы проимитировали деятельность любопытного деда. В публичном интерфейсе мы оставили возможность ***ТОЛЬКО КРУТИТЬ КРУТИЛКУ*** ```change_radiostation``` , ```change_sound_volume```. А в приватном интерфейсе у нас находятся ***ПРОЦЕССЫ, КОТОРЫЕ ПРИВОДЯТ К ТОМУ, ЧТО РАДИОСТАНЦИЯ ДЕЙСТВИТЕЛЬНО МЕНЯЕТСЯ / ГРОМКОСТЬ ПРИЕМНИКА ДЕЙСТВИТЕЛЬНО УВЕЛИЧИВАЕТСЯ***.

***Основная идея*** состоит в том, что при проектировании класса, мы запрещаем пользователю обращатсья к ***критически важным*** поведенческим свойствам (изменение расстояний обкладок конденастора и увечеличение мощности колебаний диафграмы).


***Резюме*** : инкапсулирование методов применяется для того, чтобы скрыть от пользователя внутреннюю реализацию сложных действий, которые пользователю ***АБСОЛЮТНО НЕ НУЖНЫ*** (Пример: нажатие на педаль газа в автомобиле -> пользователь жмет на газ , чтобы ***ЕХАТЬ ВПЕРЕД***, ему не нужно знать, как происходит впрыск топлива, как происходит првоерка температуры, как работает тормозная система и т.д. . ***ЕМУ ПРОСТО НУЖНО ЕХАТЬ ВПЕРЕД!!!!!!****)


## Условная-приватизация. Почему так называется?
В Python нет абсолютной приватизации (как в С++ , в Java). В Python при должном старании ***МОЖНО*** напрямую получать доступ к приватным полям и методам. Но , если так сделать - все остальные сразу заметят!
Для обхода механизма приватизации можно воспользоваться следующим синтаксисом:
```
object._<ClassName><Attribute/method Name>
```
Для чего это поддерживается? Это поддерживается для удобной реализации ***ТЕСТИРОВАНИЯ*** вашего класса.

# Вывод
Теперь мы разобрали первую составляющую ***ООП*** - инкапсуляция (свойство разделения интерфейса взаимодействия с классом на публичный/приватный).


