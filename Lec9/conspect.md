## Лекция №9. ООП. Начало.

***Проблема***: структурно-процедурный подход к созданию ПО - это достаточно удобно в контексте специфики существоваших на тот момент языков программирования (С, Fortran). Но имелся ряд проблем, который не принципиально не имел решений:
* Достаточно большая проблема - масштабирование и обновление существующих структур (состояний).
* Код был достаточно бессвязаный - достаточно тяжело устроена процедура передачи кода (как следствие - тяжелейшая отладка)
* Проблема построения новых решений на основе старых
* Проблема отсутствия разграничений пользовательского интерфейса (монитор)

***Решение проблем***: Объектно-Ориентированное программирование (```ООП```) выступает в качестве способа решения всех выше-перечисленных проблем.

* ***Определение 1 (школа/универ)*** : ```ООП``` - программирование с объектами.

* ***Определение 2 (универ)***: ```ООП``` - это подход, к созданию ПО, с использованием таких идиом как ***абстракция***, ***полиморфизм***, ***инкапсуляция*** и ***наследование***.

* ***Определение 3*** ```ООП``` - это подход к созданию ПО, основанный на эффективном использовании объектов различных классов, их взаимодействии и взаимозаменяемости. 


### Шаг 1. Инкапсуляция : это кто
***Локальная проблема***: допустим есть класс SmartPhone
```
"""
Беды с инкапсуляцией
"""

class SmartPhone:
    """
    Класс описывающий классический смартфон
    """
    def __init__(self, mark:str, resolution:int, RAM:int, freq:float):
        self.mark = mark 
        self.resolution = resolution 
        self.RAM = RAM
        self.freq = freq 
        self.like_counter = 0

    def reboot(self):
        """
        Перезагрузка
        """
        pass 

    def like(self):
        """
        Поставить лайк
        """

    def get_call(self):
        """
        Принимаем входящий звонок
        """
        pass 
```

Мы описали класс ```SmartPhone``` содержащий в себе информацию про состояние (объем памяти, частота процессора, марка смартфона , количество лайков ....). Наделили смартфон 3-мя свойствами:
* умеет перезагружаться
* умеет принимать входящий звонок
* умеет ставить лайк котам


По итогу, мы поулчили:
```
class SmartPhone:
    """
    Класс описывающий классический смартфон
    """
    def __init__(self, mark:str, resolution:int, RAM:int, freq:float):
        self.mark = mark 
        self.resolution = resolution 
        self.RAM = RAM
        self.freq = freq 
        self.like_counter = 0

    def reboot(self):
        """
        Перезагрузка
        """
        if self.RAM < 0 or self.freq < 0:
            raise Exception("ПОШЛО ЧТО-ТО НЕ ТАК. ТЕЛЕФОН СЛОМАЛСЯ. ПОДУМОЙ ЧТО ТЫ НАДЕЛАЛ") 
    
        print("Rebooting........")
        for i in range(1000000):
            i**3
            continue 
        print("Done.....")

    def like(self):
        """
        Поставить лайк
        """
        self.like_counter += 1
        print("Like coefficient:", self.like_counter * self.resolution / self.RAM)

    def get_call(self):
        """
        Принимаем входящий звонок
        """
        if self.freq <0  and (self.mark is not None) :
            raise Exception("ЛУЧШЕ НЕ БЕРИ ТРУБКУ. ТЕЛЕФОН СОБРАН ГДЕ-ТО В ГАРАЖЕ")
        print("Get call .....")
    

samsung = SmartPhone("Samsung", 1440, 3, 1.9)
iphone = SmartPhone("IPhone", 10000, 400000, 99999999999992.1)
my_phone = SmartPhone("MyPhone", 1, 1, 1)


### Начнем работать с объектами
### 1. Часть. Общая перезагрузка
samsung.reboot()
iphone.freq = -30000000
samsung.resolution = -100
my_phone.reboot()
### 2. Часть . Прием входящих звонков
iphone.mark = "IPear" # Поскольку под крышку я уже залез - телефон слетел с гарантии . И я хочу его переназвать
samsung.get_call()
my_phone.get_call()


### 3. Часть . Попробуем лайкнуть котов
samsung.like()
my_phone.like()
```

***Какой вывод?***  В данный момент у наших объектов нет никакого механизма , отделяющего доступ к ***КЛЮЧЕВЫМ ХАРАКТЕРИСТИКАМ** от ***ПОЛЬЗОВАТЕЛЬСКОГО ИНТЕРФЕЙСА***.


***Введем формальное определение***
* ```Инкапсуляция (инкапсулирвоание)``` - процесс разделения ***пользовательского интерфейса*** и сокрытия ***ключевых характеристик*** (процесс сокрытия реализации). 

Пример: монитор и его задняя стенка. В качестве пользовательского интерфейса выступает набор кнопок и адаптеров на задней панели. В то же самое время - реализация монитора (железки, чипы, микросхемы) - сокрыты (инкапсулирвоаны) в его корпус.

### Механизм приватизации.
***Механизм приватизации*** - общие рекомендации (идея реализиции)  по построению класса с ***приватной (сокрытой) секцией*** и ***публичной (открытой, пользовательской) секцией***

```
class SmartPhone:
    public:
        //Тут описывается все, с чем может взаимодействоать пользователь
        press_on()
        press_off()
        charge()
        tap()
        pontovatcya() if price > 100000
    private:
        //Тут описывается все, что влияет на внутреннюю работу смарфтоны
        RAM = 3240
        freq = 1.4
        power = 1.3
        system_reboot()
        puskat_tok_po_provodyam()
        get_radio()
        uncharing()
```

Механизм приватизации, основанный на использовании ключевых слов (модификаторов доступа) ```private, public``` называют ***явным механизмом сокрытия (инкапсулирвоания)***.


В Python нет явного способы инкапсулирования блоков. Говорят, что в Python принята идея ```условной приватизации```.


### Условная приватизация
Для того, чтобы сделать ***условно приватное поле(свойство)*** у класса, необходимо начать имя данного поля (свойства) с ```двух нижних подчеркиваний Ex: __bob, __RAM, __coding(self)```.

***При использовании механизма условной приватизации (атрибутов)*** в Python мы поулчаем 2 следствия:
* Если попытаться изменить значение атрибута через обращение ```samsung.__RAM = 200``` ***ЗА ПРЕДЕЛАМИ КЛАССА*** , то значение атрибута объекта не изменится (исключения не будет, запрос просто будет проигнорирован)
* Если попытаться ***ПРОЧИТАТЬ*** из приватизированного поля - получим исключение, сообщающее о том, что ***будто бы*** у объекта вообще нет такого атрибута.

### Предоставление контролируемого доступа к сокрытым атрибутам при помощи get()/set() методов.
